= Mastermind - Rust

Determine optimal mastermind plays for different permutations of the rules.

This program determines how to optimally play a game of mastermind with _n_ pegs
in _m_ colors, supplied by the user at the command line. It aims to do so
without the aid of heuristics (a la Knuth), just because it is fun. We may add a
mode which uses heuristics at some point in the future, however.

The current draft recursively expands trees based on sets of possible guesses
and possible answers. Subsequent guesses partition remaining answers into bins
keyed by reponse code. Expansion stops when all possible guesses are
differentiated into singleton bins by a sequence of guesses. Expanded subtrees
are compared and optimal trees (by depth) are kept. The best tree is printed.

== Performance Analysis Changelog
The fun of this project is tuning the codebase, so below we discuss how we
collect and analyze performance data and what measured changes we have made so
far (all of which are tagged in git).

=== Performance Analysis with Perf and Hotspot
I originally generated "flamegraphs" <<cpuflamegraphs>> with Brendan Gregg's
toolchain <<brendangregg>>. Now I prefer to analyze perf data with hotspot
<<hotspot>>.

Benchmark tests are defined using the `#[bench]` nightly feature. We build, run,
and analyze performance using the followng commands:
[source, bash]
----
cargo clean
cargo bench --no-run
perf record --call-graph dwarf target/release/deps/mastermind-xyz --bench <1>
hotspot perf.data
----
<1> We can pass the name of a specific bench after the `--bench` argument as
    well.

=== Changelog
Each tagged performance improvement is described below by a table of performance
benchmarks. "Test _m^n_" stands for a benchmark to exhaustively identify the
optimal mastermind tree of base _m_ and length _n_ (i.e. _n_ pegs from any of
_m_ colors, of which there are _m^n_.)

==== Tag 2-isomorph-cache
_Caching_: Do not evaluate a RefTree if the guess code from which it is
generated produces an answers-by-response mapping that is _isomorphic_ to one
already evaluated. This eliminates a great deal of memory management, esp. for
larger problem sets, by pruning candidates across all levels of evaluation.

Performance Metrics
|===
| Test _m^n_  | 2^2                                 | 3^2
| Performance | 32,362 ns/iter (+/- 469)            | 6,331,574 ns/iter (+/- 210,728)
| Change      | approx. 37% (19,209 ns/iter) faster | approx. 94% (99,771,028 ns/iter) faster
|===

==== Tag 1-reference-passing
_Reference Passing_: Eliminate unecessary data cloning by sharing immutable
references to Code instances.

Performance Metrics
|===
| Test _m^n_  | 2^2                                 | 3^2
| Performance | 51,571 ns/iter (+/- 404)            | 106,102,602 ns/iter (+/- 1,280,047)
| Change      | approx. 25% (17,602 ns/iter) faster | N/A
|===

==== Tag 0-init
_Initial Commit_: Rough and unoptimized. Something simple on the screen.

|===
| Test _m^n_  | 2^2
| Performance | 69,173 ns/iter (+/- 1,451)
|===

[bibliography]
== References
 - [[[cpuflamegraphs, 1]]] http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html
 - [[[brendangregg, 2]]] https://github.com/brendangregg/FlameGraph
 - [[[hotspot, 3]]] https://github.com/KDAB/hotspot
